
#Software development process
2016-06-01

Software development is a process with different steps we have to accomplish.
In software development methodology, the software development work is split in different phases for the sake of simplicity and efficiency of the planning and management.
The different selection of the stages and phases as well as the selection of the structure they follow, it is a complex task. To solve this question the community proposed several framework solutions and paradigms in order to make the planning and management easier.
There is no silver bullet solution, so we have to decide by considering our common software goal, our team, if there is a target user and the possible interaction with them among other considerations.

The main tasks a process of software development can contain are:
- Requirement analysis: phase where we have to analyze the requirements that the next complete product has to meet.The requirements should be documented, actionable, measurable, testable, traceable, related to identified business needs or opportunities, and defined to a level of detail sufficient for system design.
There are different types of requirements to meet as customer requirements, architectural requirements, structural requirements, behavioral requirements, functional requirements, design requirements among others.
- Software design: how the requirements has to be met. Build the description map of the software. There are utilities and methods to do it as UML.
- Implementation: the actual programming the code.
- Testing: ensuring that the code works as it is supposed to work.
- Integration: Integrating the part of the code in the other parts of codes. Some times implies to design APIs and code the actual interaction code, between both parts of software.
- Deployment: ensure that the software it is valid to use in the system it has to be used.
- Maintenance: fix bugs after delivery and adaptation to new cases.

Sometimes the conceptual border (or even the actual output) between some of them are fuzzier depending on the problem we want to solve.

The different paradigms and frameworks of software development are actual different possible combinations of these tasks and how they have to be place in a time-line and how the transitions between tasks have to be done.

The most simple ones are:
- Waterfall: sequential model.
- Prototyping: first planning and after a sequential loops of complete implementation and testing. The output of each loop are workable software with reduced functionalities (incomplete version of the final software). Each loop the developers adds new functionalities and improve the existing ones. There are different ways to select the prototypes to code or the selection of the functionalities to code first.
- Incremental development. Loop of mini-waterfalls where the final goal software is split in parts.
- Iterative and incremental: Loops of development in which the result of the codes are sometimes different parts of the code and others and upgrading of the actual programmed code.
- Agile development or others, they are other combinations and specifications, summed with the use of a collections of tools to favor communication, flexibility in coding and also reducing coding risk of bugs and not matching customer goals.

The border between the different models and paradigms are also fuzzy. Projects are usually carry out using parts of different ones.
The different models are focus mainly in reducing the project risk of fail, increase quality of code in terms of bugs and matching the needs of the customer but also 
Of course, depending on the nature of the project and the conditions among the project some of them can do it better in these goals or others can perform very badly.

As I said before, there are not silver bullets and even for each design pattern we can create there are drawbacks associated, bad design patterns called anti-patterns, sometimes even with the same properties as the originals.
So, any software development method or framework needs balance, be practical and easy to implement.

***Tags***: Software engineering, Software development

### See also
[Agile software development](/agile_software_development), [Waterfall software development](/waterfall_software_development)
## Papers
* Brooks, F. P. , J. (1987). ["No Silver Bulletâ€”Essence and Accidents of Software Engineering"](http://faculty.salisbury.edu/~xswang/Research/Papers/SERelated/no-silver-bullet.pdf)
* Koenig, Andrew (March-April 1995). "Patterns and Antipatterns". Journal of Object-Oriented Programming 8 (1998). The patterns handbook: techniques, strategies, and applications. Cambridge, U.K.: Cambridge University Press.

## Books
* Holzner, Steven; Purchase, Barbara. (2006). [Design Patterns for Dummies](https://www.goodreads.com/book/show/298107.Design_Patterns_for_Dummies).
* Gamma, Helm, Johnson & Vlissides (1994). Design Patterns (the Gang of Four book). Addison-Wesley.
* Lasater, Christopher G. (2006) [Design Patterns](https://www.goodreads.com/book/show/475634.Design_Patterns). Wordware Publishing
* Budgen, D. (2003). [Software design](). Harlow, Eng.: Addison-Wesley
* Norvig, Peter (1998). [Design Patterns in Dynamic Languages.](http://www.norvig.com/design-patterns/)
* Braude, Eric J. (2003). [Software Design: From Programming To Architecture](https://www.goodreads.com/book/show/4008807-software-design).
* Fowler, Martin; Beck, Kent; Roberts, Don (1999). [Refactoring: Improving the Design of Existing Code](https://www.goodreads.com/book/show/44936.Refactoring). Addison-Wesley Professional
* Kerievsky, Joshua; Fowler, Martin; Johnson, Ralph (2004). [Refactoring to patterns](https://www.goodreads.com/book/show/85041.Refactoring_to_Patterns). Addison-Wesley Professional


